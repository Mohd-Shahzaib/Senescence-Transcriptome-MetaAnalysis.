# ============================================================
# RNA-seq pipeline: DESeq2 + VST + SVA (visualization) + LFC shrinkage
# Acute vs Control and Replicative vs Control
# Outputs: PCA, normalized counts, DE tables, volcano, heatmaps,
#          GO and Reactome enrichment with universe, overlaps with Fisher,
#          common DEGs, senescence marker heatmaps, optional SV sensitivity.
# ============================================================

suppressPackageStartupMessages({
  library(DESeq2)
  library(limma)
  library(sva)
  library(ggplot2)
  library(pheatmap)
  library(readr)
  library(dplyr)
  library(tidyr)
  library(AnnotationDbi)
  library(org.Hs.eg.db)
  library(clusterProfiler)
  library(ReactomePA)
  library(ggrepel)
  library(ggvenn)
  library(stringr)
  library(apeglm)  
  library(ashr)    
})

set.seed(20250825)

# -------------------------------
# 1) Load counts and metadata
# -------------------------------
counts_file <- "countmergematrix.csv"
meta_file   <- "metadata_strict_even_batches_ordered.csv"

raw_counts <- read.csv(counts_file, row.names = 1, check.names = FALSE)
meta       <- read.csv(meta_file, row.names = 1)

samples <- intersect(colnames(raw_counts), rownames(meta))
if (length(samples) < 2) stop("No overlapping samples between counts and metadata")

raw_counts <- raw_counts[, samples, drop = FALSE]
meta       <- meta[samples, , drop = FALSE]
stopifnot(identical(colnames(raw_counts), rownames(meta)))

meta$Condition <- tolower(trimws(meta$Condition))
meta$Batch     <- trimws(meta$Batch)

meta$Condition <- factor(meta$Condition, levels = c("control","replicative_senescence","acute_senescence"))
meta$Batch     <- factor(meta$Batch)
meta$Condition <- droplevels(meta$Condition)
meta$Batch     <- droplevels(meta$Batch)

# -------------------------------
# 2) Build DESeq2 object and run DE
# -------------------------------
dds <- DESeqDataSetFromMatrix(countData = round(raw_counts),
                              colData   = meta,
                              design    = ~ Batch + Condition)

keep <- rowSums(counts(dds) >= 10) >= 2
dds  <- dds[keep, ]

dds <- DESeq(dds)
vsd <- vst(dds, blind = TRUE)

# -------------------------------
# 3) PCA before and after SVA-based removal (visualization only)
# -------------------------------
pca_plot <- function(mat, meta, title){
  pca <- prcomp(t(mat), center = TRUE)
  var_expl <- 100 * (pca$sdev^2 / sum(pca$sdev^2))
  df <- data.frame(pca$x[,1:2], meta)
  ggplot(df, aes(PC1, PC2, color = Condition, shape = Batch)) +
    geom_point(size = 3, alpha = 0.9) +
    labs(title = title,
         x = paste0("PC1 (", round(var_expl[1], 1), "%)"),
         y = paste0("PC2 (", round(var_expl[2], 1), "%)")) +
    theme_bw(base_size = 14)
}

plt_pca_before <- pca_plot(assay(vsd), meta, "PCA before batch correction")
ggsave("pca_before_batch.png", plt_pca_before, width = 7, height = 6, dpi = 300)

mod  <- model.matrix(~ Condition + Batch, data = meta)
mod0 <- model.matrix(~ 1, data = meta)
set.seed(20250825)  # fix RNG right before svaseq for reproducibility
sva_res <- svaseq(assay(vsd), mod, mod0)
write.csv(sva_res$sv, "sva_surrogate_variables.csv", row.names = FALSE)

vsd_rm <- removeBatchEffect(assay(vsd),
                            batch = meta$Batch,
                            covariates = sva_res$sv,
                            design = model.matrix(~ Condition, data = meta))

plt_pca_after <- pca_plot(vsd_rm, meta, "PCA after batch correction (SVA for visualization)")
ggsave("pca_after_batch.png", plt_pca_after, width = 7, height = 6, dpi = 300)

# Save normalized matrices for review
write.csv(counts(dds, normalized = TRUE), "normalized_counts_deseq2.csv")
write.csv(assay(vsd),                     "vst_matrix_before_batch.csv")
write.csv(vsd_rm,                         "vst_matrix_after_batch.csv")

# -------------------------------
# 4) Differential results with LFC shrinkage
# -------------------------------
# FIXED LFC SHRINKAGE - robust coef detection with apeglm fallback
get_shrunk <- function(dds, contrast_vec){
  res <- results(dds, contrast = contrast_vec, alpha = 0.05)

  rn <- resultsNames(dds)
  coef_guess <- paste0(contrast_vec[1], "_", contrast_vec[2], "_vs_", contrast_vec[3])

  coef_name <- rn[rn == coef_guess]
  if (length(coef_name) == 0) {
    pm <- rn[grepl(paste0("^", gsub("\\+", "\\\\+", coef_guess), "$"), rn)]
    if (length(pm) == 1) coef_name <- pm
  }
  if (length(coef_name) == 0) {
    pm2 <- rn[grepl(coef_guess, rn, fixed = TRUE)]
    if (length(pm2) == 1) coef_name <- pm2
  }
  if (length(coef_name) != 1) {
    stop(paste0("Could not identify a unique coef for shrinkage. ",
                "Wanted: ", coef_guess, " | Available: ",
                paste(rn, collapse = ", ")))
  }

  shrink_type <- if (requireNamespace("apeglm", quietly = TRUE)) "apeglm" else "ashr"

  res_shr <- lfcShrink(dds, coef = coef_name, type = shrink_type)

  res_shr$baseMean <- res$baseMean
  res_shr$pvalue   <- res$pvalue
  res_shr$padj     <- res$padj

  as.data.frame(res_shr) |>
    tibble::rownames_to_column("Gene")
}

res_rep    <- get_shrunk(dds, c("Condition","replicative_senescence","control"))
res_acute  <- get_shrunk(dds, c("Condition","acute_senescence","control"))

write_csv(res_rep,   "DE_full_replicative_vs_control_shrunk.csv")
write_csv(res_acute, "DE_full_acute_vs_control_shrunk.csv")

# -------------------------------
# 5) Annotate, filter DEGs, and save
# -------------------------------
annotate_symbols <- function(df){
  sym <- df$Gene
  map <- AnnotationDbi::select(org.Hs.eg.db, keys = sym, keytype = "SYMBOL",
                               columns = c("SYMBOL","ENTREZID","GENENAME"))
  df %>%
    left_join(map %>% dplyr::distinct(SYMBOL, ENTREZID, GENENAME),
              by = c("Gene" = "SYMBOL")) %>%
    dplyr::rename(Symbol = Gene, Description = GENENAME, EntrezID = ENTREZID)
}

rep_anno   <- annotate_symbols(res_rep)
acute_anno <- annotate_symbols(res_acute)

filter_deg <- function(df){
  df %>%
    filter(!is.na(log2FoldChange) & !is.na(padj)) %>%
    filter(!is.na(Symbol) & Symbol != "") %>%
    filter(!grepl("^LOC", Symbol, ignore.case = TRUE)) %>%
    filter(is.na(Description) | !grepl("pseudogene", Description, ignore.case = TRUE)) %>%
    filter(padj < 0.05, abs(log2FoldChange) >= 1, baseMean >= 10)
}

rep_deg    <- filter_deg(rep_anno)
acute_deg  <- filter_deg(acute_anno)

rep_up     <- rep_deg   %>% filter(log2FoldChange > 0)
rep_down   <- rep_deg   %>% filter(log2FoldChange < 0)
acute_up   <- acute_deg %>% filter(log2FoldChange > 0)
acute_down <- acute_deg %>% filter(log2FoldChange < 0)

write_csv(rep_up,     "replicative_up_degs.csv")
write_csv(rep_down,   "replicative_down_degs.csv")
write_csv(acute_up,   "acute_up_degs.csv")
write_csv(acute_down, "acute_down_degs.csv")

cat("Replicative:", nrow(rep_up), "up |", nrow(rep_down), "down\n")
cat("Acute:", nrow(acute_up), "up |", nrow(acute_down), "down\n")

# -------------------------------
# 6) Common DEGs and Venns (Symbols)
# -------------------------------
common_up   <- intersect(acute_up$Symbol, rep_up$Symbol)
common_down <- intersect(acute_down$Symbol, rep_down$Symbol)

acute_up  %>% filter(Symbol %in% common_up)   %>% write_csv("common_up_degs.csv")
acute_down %>% filter(Symbol %in% common_down) %>% write_csv("common_down_degs.csv")

png("venn_degs_up.png", width = 1600, height = 1200, res = 300)
print(ggvenn(list(Acute_Up = acute_up$Symbol, Replicative_Up = rep_up$Symbol),
             fill_color = c("#E41A1C", "#377EB8"),
             stroke_size = 0.8, set_name_size = 5) +
      ggtitle("Common upregulated DEGs"))
dev.off()

png("venn_degs_down.png", width = 1600, height = 1200, res = 300)
print(ggvenn(list(Acute_Down = acute_down$Symbol, Replicative_Down = rep_down$Symbol),
             fill_color = c("#4DAF4A", "#984EA3"),
             stroke_size = 0.8, set_name_size = 5) +
      ggtitle("Common downregulated DEGs"))
dev.off()

# -------------------------------
# 7) Volcano plots (cap only for display)
# -------------------------------
plot_volcano <- function(df, title, xcap = 8, ycap = 50){
  df2 <- df %>%
    mutate(padj_plot = pmax(padj, .Machine$double.xmin),
           log2FC_plot = pmin(pmax(log2FoldChange, -xcap), xcap),
           Regulation = dplyr::case_when(
             padj < 0.05 & log2FoldChange >= 1  ~ "Up",
             padj < 0.05 & log2FoldChange <= -1 ~ "Down",
             padj < 0.05                        ~ "Sig",
             TRUE                               ~ "NS"
           ))
  senescence_genes <- c("CDKN2A","CDKN1A","TP53","CDKN2B","RB1",
                        "STAT1","IL6","IL1A","IL1B",
                        "CXCL1","CXCL2","CXCL8","CXCL12",
                        "CCL2","CCL20",
                        "LMNB1","HELLS","CCNB1","CDK1","CDC25C",
                        "CCNE2","E2F1","MKI67","PLK1","TOP2A",
                        "MCM2","MCM3","MCM4","MCM5","MCM6","MCM7",
                        "EZH2","CDKN2D","GDF15","CXCL10","CXCL11",
                        "CCL5","TNFRSF10C","TNFRSF10D","SERPINE1","GLB1")
  df2$Label <- ifelse(df2$Symbol %in% senescence_genes, df2$Symbol, NA)

  ggplot(df2, aes(x = log2FC_plot, y = -log10(padj_plot), color = Regulation)) +
    geom_point(alpha = 0.7, size = 1.6) +
    geom_vline(xintercept = c(-1,1), linetype = "dashed") +
    geom_hline(yintercept = -log10(0.05), linetype = "dashed") +
    geom_text_repel(aes(label = Label), size = 3, color = "black", max.overlaps = 100) +
    scale_color_manual(values = c("Up"="#E41A1C","Down"="#377EB8","Sig"="#4DAF4A","NS"="grey70")) +
    coord_cartesian(xlim = c(-xcap, xcap), ylim = c(0, ycap)) +
    labs(title = title, x = "log2 fold change", y = "-log10 adjusted p value", color = "") +
    theme_minimal(base_size = 13) +
    theme(plot.title = element_text(hjust = 0.5, face = "bold"))
}

ggsave("volcano_acute.jpg",       plot_volcano(acute_anno, "Acute vs Control", xcap = 6, ycap = 30), width=9, height=7, dpi=1200)
ggsave("volcano_replicative.jpg", plot_volcano(rep_anno,   "Replicative vs Control", xcap = 6, ycap = 30), width=9, height=7, dpi=1200)

# -------------------------------
# 8) Sample-level heatmaps for top genes
# -------------------------------
plot_top_heatmap <- function(vsd_assay, meta, deg_table, title, outfile){
  top_up   <- deg_table %>% filter(log2FoldChange > 0) %>% arrange(padj) %>% slice_head(n = 25)
  top_down <- deg_table %>% filter(log2FoldChange < 0) %>% arrange(padj) %>% slice_head(n = 25)
  top_syms <- unique(c(top_up$Symbol, top_down$Symbol))
  top_syms <- top_syms[top_syms %in% rownames(vsd_assay)]
  if (length(top_syms) < 2) return(invisible(NULL))
  mat <- vsd_assay[top_syms, ]
  mat <- t(scale(t(mat)))
  ann_col <- data.frame(Condition = meta$Condition, Batch = meta$Batch)
  rownames(ann_col) <- rownames(meta)
  png(outfile, width = 1800, height = 1400, res = 300)
  pheatmap(mat,
           annotation_col = ann_col,
           show_colnames = FALSE,
           main = title,
           color = colorRampPalette(c("blue","white","red"))(200),
           fontsize = 8, border_color = NA)
  dev.off()
}

plot_top_heatmap(assay(vsd), meta, acute_deg, "Top 25 up and 25 down (Acute)", "heatmap_acute_top50_samples.png")
plot_top_heatmap(assay(vsd), meta, rep_deg,   "Top 25 up and 25 down (Replicative)", "heatmap_replicative_top50_samples.png")

# -------------------------------
# 9) Enrichment universe (tested genes)
# -------------------------------
tested_symbols <- rownames(dds)
map_univ <- AnnotationDbi::select(org.Hs.eg.db, keys = tested_symbols, keytype = "SYMBOL",
                                  columns = "ENTREZID") %>% dplyr::distinct(SYMBOL, ENTREZID)
universe_entrez <- unique(na.omit(map_univ$ENTREZID))

map_symbols_to_entrez <- function(sym_vec){
  m <- AnnotationDbi::select(org.Hs.eg.db, keys = sym_vec, keytype = "SYMBOL",
                             columns = "ENTREZID") %>% dplyr::distinct(SYMBOL, ENTREZID)
  unique(na.omit(m$ENTREZID))
}

# -------------------------------
# 10) GO BP enrichment per direction
# -------------------------------
run_go <- function(sym_vec){
  gids <- map_symbols_to_entrez(sym_vec)
  if (length(gids) < 5) return(NULL)
  enrichGO(gene = gids,
           OrgDb = org.Hs.eg.db,
           keyType = "ENTREZID",
           ont = "BP",
           pAdjustMethod = "BH",
           pvalueCutoff = 0.05,
           qvalueCutoff = 0.05,
           universe = universe_entrez,
           readable = TRUE)
}

ego_acute_up   <- run_go(acute_up$Symbol)
ego_acute_down <- run_go(acute_down$Symbol)
ego_rep_up     <- run_go(rep_up$Symbol)
ego_rep_down   <- run_go(rep_down$Symbol)

if (!is.null(ego_acute_up))   write_csv(as.data.frame(ego_acute_up),   "go_bp_acute_up.csv")
if (!is.null(ego_acute_down)) write_csv(as.data.frame(ego_acute_down), "go_bp_acute_down.csv")
if (!is.null(ego_rep_up))     write_csv(as.data.frame(ego_rep_up),     "go_bp_replicative_up.csv")
if (!is.null(ego_rep_down))   write_csv(as.data.frame(ego_rep_down),   "go_bp_replicative_down.csv")

# -------------------------------
# 11) Reactome enrichment per direction
# -------------------------------
run_reactome <- function(sym_vec){
  gids <- map_symbols_to_entrez(sym_vec)
  if (length(gids) < 5) return(NULL)
  enrichPathway(gene = gids,
                organism = "human",
                pvalueCutoff = 0.05,
                pAdjustMethod = "BH",
                qvalueCutoff = 0.05,
                universe = universe_entrez,
                readable = TRUE)
}

ere_acute_up   <- run_reactome(acute_up$Symbol)
ere_acute_down <- run_reactome(acute_down$Symbol)
ere_rep_up     <- run_reactome(rep_up$Symbol)
ere_rep_down   <- run_reactome(rep_down$Symbol)

if (!is.null(ere_acute_up))   write_csv(as.data.frame(ere_acute_up),   "reactome_acute_up.csv")
if (!is.null(ere_acute_down)) write_csv(as.data.frame(ere_acute_down), "reactome_acute_down.csv")
if (!is.null(ere_rep_up))     write_csv(as.data.frame(ere_rep_up),     "reactome_replicative_up.csv")
if (!is.null(ere_rep_down))   write_csv(as.data.frame(ere_rep_down),   "reactome_replicative_down.csv")

# -------------------------------
# 12) Overlap and Fisher combining on IDs (not names)
# -------------------------------
combine_two_enrich <- function(df_a, df_b, id = "ID", name = "Description", pcol = "pvalue"){
  if (is.null(df_a) || is.null(df_b)) return(NULL)
  a <- as.data.frame(df_a)
  b <- as.data.frame(df_b)
  if (!all(c(id, name, pcol) %in% colnames(a))) return(NULL)
  if (!all(c(id, name, pcol) %in% colnames(b))) return(NULL)
  j <- dplyr::inner_join(
    a %>% dplyr::select(!!sym(id), !!sym(name), p_a = !!sym(pcol)),
    b %>% dplyr::select(!!sym(id), !!sym(name), p_b = !!sym(pcol)),
    by = c(id, name)
  )
  if (nrow(j) == 0) return(NULL)
  j %>%
    dplyr::mutate(
      Fisher_chisq = -2 * (log(p_a) + log(p_b)),
      Fisher_p = pchisq(Fisher_chisq, df = 4, lower.tail = FALSE),
      Fisher_padj = p.adjust(Fisher_p, method = "BH")
    ) %>%
    dplyr::arrange(Fisher_padj)
}

go_up_overlap    <- combine_two_enrich(ego_acute_up,   ego_rep_up)
go_down_overlap  <- combine_two_enrich(ego_acute_down, ego_rep_down)
re_up_overlap    <- combine_two_enrich(ere_acute_up,   ere_rep_up)
re_down_overlap  <- combine_two_enrich(ere_acute_down, ere_rep_down)

if (!is.null(go_up_overlap))   write_csv(go_up_overlap,   "go_bp_overlap_up_with_fisher.csv")
if (!is.null(go_down_overlap)) write_csv(go_down_overlap, "go_bp_overlap_down_with_fisher.csv")
if (!is.null(re_up_overlap))   write_csv(re_up_overlap,   "reactome_overlap_up_with_fisher.csv")
if (!is.null(re_down_overlap)) write_csv(re_down_overlap, "reactome_overlap_down_with_fisher.csv")

# -------------------------------
# 13) Venn on IDs for GO and Reactome
# -------------------------------
plot_venn_ids <- function(df_a, df_b, title, out){
  if (is.null(df_a) || is.null(df_b)) return(invisible(NULL))
  a <- as.data.frame(df_a)
  b <- as.data.frame(df_b)
  if (!("ID" %in% colnames(a) && "ID" %in% colnames(b))) return(invisible(NULL))
  p <- ggvenn(list(A = a$ID, B = b$ID),
              fill_color = c("#E41A1C","#377EB8"),
              stroke_size = 0.8, set_name_size = 5) + ggtitle(title)
  ggsave(out, p, width = 10, height = 7, dpi = 300)
}

plot_venn_ids(ego_acute_up,   ego_rep_up,   "GO BP overlap (IDs) Acute Up vs Replicative Up",       "go_bp_venn_up_ids.png")
plot_venn_ids(ego_acute_down, ego_rep_down, "GO BP overlap (IDs) Acute Down vs Replicative Down",   "go_bp_venn_down_ids.png")
plot_venn_ids(ere_acute_up,   ere_rep_up,   "Reactome overlap (IDs) Acute Up vs Replicative Up",    "reactome_venn_up_ids.png")
plot_venn_ids(ere_acute_down, ere_rep_down, "Reactome overlap (IDs) Acute Down vs Replicative Down","reactome_venn_down_ids.png")

# -------------------------------
# 14) Top common terms bar plots (Fisher adjusted p)
# -------------------------------
plot_top_common <- function(df_overlap, title, out, n = 20){
  if (is.null(df_overlap)) return(invisible(NULL))
  top <- df_overlap %>% dplyr::slice_head(n = n) %>% dplyr::mutate(Description = stringr::str_wrap(Description, 40))
  p <- ggplot(top, aes(x = reorder(Description, -log10(Fisher_padj)),
                       y = -log10(Fisher_padj))) +
    geom_col() + coord_flip() +
    labs(title = title, x = "Term", y = "-log10 Fisher adjusted p") +
    theme_minimal(base_size = 12) +
    theme(plot.title = element_text(hjust = 0.5, face = "bold"))
  ggsave(out, p, width = 10, height = 7, dpi = 300)
}

plot_top_common(go_up_overlap,   "Top GO BP terms common in Acute Up and Replicative Up",         "go_bp_overlap_up_top20.png")
plot_top_common(go_down_overlap, "Top GO BP terms common in Acute Down and Replicative Down",     "go_bp_overlap_down_top20.png")
plot_top_common(re_up_overlap,   "Top Reactome terms common in Acute Up and Replicative Up",      "reactome_overlap_up_top20.png")
plot_top_common(re_down_overlap, "Top Reactome terms common in Acute Down and Replicative Down",  "reactome_overlap_down_top20.png")

# -------------------------------
# 15) Fixed panel of ~50 senescence markers (heatmaps)
# -------------------------------
senescence_genes <- c(
  "CDKN2A","CDKN1A","TP53","CDKN2B","RB1",
  "STAT1","IL6","IL1A","IL1B",
  "CXCL1","CXCL2","CXCL8","CXCL12",
  "CCL2","CCL20",
  "LMNB1","HELLS","CCNB1","CDK1","CDC25C",
  "CCNE2","E2F1","MKI67","PLK1","TOP2A",
  "MCM2","MCM3","MCM4","MCM5","MCM6","MCM7",
  "EZH2","CDKN2D","GDF15","CXCL10","CXCL11",
  "CCL5","TNFRSF10C","TNFRSF10D","SERPINE1","GLB1",
  "H2AFX","ATM","ATR","BCL2","BAX","PML","HMGA2","FOXM1","SIRT1","SOD2"
)

plot_marker_heatmap <- function(vsd_assay, meta, markers, title, outfile){
  keep <- intersect(markers, rownames(vsd_assay))
  if (length(keep) < 2) return(invisible(NULL))
  mat <- vsd_assay[keep, ]
  mat <- t(scale(t(mat)))
  ann_col <- data.frame(Condition = meta$Condition, Batch = meta$Batch)
  rownames(ann_col) <- rownames(meta)
  png(outfile, width = 1800, height = 2400, res = 400)
  pheatmap(mat,
           annotation_col = ann_col,
           cluster_rows = TRUE,
           cluster_cols = FALSE,
           color = colorRampPalette(c("blue","white","red"))(200),
           breaks = seq(-4, 4, length.out = 201),
           main = title,
           fontsize = 9, fontsize_row = 8,
           border_color = NA)
  dev.off()
}

plot_marker_heatmap(assay(vsd), meta, senescence_genes,
                    "50 Senescence Genes. Acute vs Control", "heatmap_senescence50_acute.png")
plot_marker_heatmap(assay(vsd), meta, senescence_genes,
                    "50 Senescence Genes. Replicative vs Control", "heatmap_senescence50_replicative.png")

# -------------------------------
# 16) Optional sensitivity with SVs in the design
# -------------------------------
do_sensitivity_with_SVs <- FALSE
if (do_sensitivity_with_SVs) {
  sv_df <- as.data.frame(sva_res$sv)
  colnames(sv_df) <- paste0("SV", seq_len(ncol(sv_df)))
  meta2 <- cbind(meta, sv_df)
  design_sv <- as.formula(paste("~", paste(c("Batch", colnames(sv_df), "Condition"), collapse = " + ")))
  dds_sv <- DESeqDataSetFromMatrix(countData = round(raw_counts),
                                   colData = meta2,
                                   design = design_sv)
  keep2 <- rowSums(counts(dds_sv) >= 10) >= 2
  dds_sv <- dds_sv[keep2, ]
  dds_sv <- DESeq(dds_sv)
  res_rep_sv    <- get_shrunk(dds_sv, c("Condition","replicative_senescence","control"))
  res_acute_sv  <- get_shrunk(dds_sv, c("Condition","acute_senescence","control"))
  write_csv(res_rep_sv,   "DE_full_replicative_vs_control_shrunk_withSV.csv")
  write_csv(res_acute_sv, "DE_full_acute_vs_control_shrunk_withSV.csv")
}

# -------------------------------
# 17) Reproducibility footer
# -------------------------------
sink("sessionInfo.txt")
print(sessionInfo())
sink()

message("All steps complete.")
